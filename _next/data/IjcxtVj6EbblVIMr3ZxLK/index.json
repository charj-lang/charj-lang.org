{"pageProps":{"intro":"\n# Charj\n\nThe home of the Charj website \n\nCharj Lang 是一个使用 Rust 编写的**描述式**、**中间**编程语言。其主要用途是：\n\n - legacy system migration.\n - domain model design for languages.\n - compile languages. for examples, JavaScript to WASM.\n     - visualize architecture.\n     - a quick DSL maker's infrastructure. (TBD)\n\n## Compiler Workflow\n\n```python\ndef hello():\n    print('hello world')\n```\n\n上下游支撑项目：\n\n1. 语言转换：[Charj Poet](https://github.com/charj-lang/charj-poet)\n2. IDEA 插件: [Intellij Charj](https://github.com/charj-lang/intellij-charj)\n3. Charj 项目：[Charj](https://github.com/charj-lang/charj)\n4. Scie 语言识别引擎：[Scie](https://github.com/charj-lang/scie)\n\n\n### Total compiler flow\n\n```step-line\n - origin language\n - Scie (tokenizer)\n - Poet DSL 1\n - Charj Poet\n - Charj code (charj compiler)\n - Poet DSL 2\n - Charj Lang Generate API\n - other language\n```\n\n### 流程设计\n\n#### 1. 解析\n\nVisual Studio Code 使用 Textmate 的语法来解析不同的语言。如下的语言\n\n```c\n#include <stdio.h>\nint main() {\n  printf(\\\"Hello, World!\\\");\n  return 0;\n}\n```\n\n将会被解析为：\n\n```bash\n- token from 0 to 1 () with scopes C\n- token from 0 to 1 (#) with scopes C, meta.preprocessor.include.c, , punctuation.definition.directive.c\n- token from 1 to 8 (include) with scopes C, meta.preprocessor.include.c, \n- token from 8 to 9 ( ) with scopes C, meta.preprocessor.include.c\n- token from 9 to 10 (<) with scopes C, meta.preprocessor.include.c, string.quoted.other.lt-gt.include.c, punctuation.definition.string.begin.c\n- token from 10 to 17 (stdio.h) with scopes C, meta.preprocessor.include.c, string.quoted.other.lt-gt.include.c\n- token from 17 to 18 (>) with scopes C, meta.preprocessor.include.c, string.quoted.other.lt-gt.include.c, punctuation.definition.string.end.c\n- token from 0 to 3 (int) with scopes C, storage.type.built-in.primitive.c\n- token from 3 to 4 ( ) with scopes C\n- token from 4 to 8 (main) with scopes C, meta.function.c, meta.function.definition.parameters.c, entity.name.function.c\n- token from 8 to 9 (() with scopes C, meta.function.c, meta.function.definition.parameters.c, punctuation.section.parameters.begin.bracket.round.c\n- token from 9 to 10 ()) with scopes C, meta.function.c, meta.function.definition.parameters.c, punctuation.section.parameters.end.bracket.round.c\n- token from 10 to 11 ( ) with scopes C\n- token from 11 to 12 ({) with scopes C, meta.block.c, punctuation.section.block.begin.bracket.curly.c\n- token from 0 to 6 (printf) with scopes C, meta.block.c, meta.function-call.c, entity.name.function.c\n- token from 6 to 7 (() with scopes C, meta.block.c, meta.function-call.c, punctuation.section.arguments.begin.bracket.round.c\n- token from 7 to 8 (\") with scopes C, meta.block.c, meta.function-call.c, string.quoted.double.c, punctuation.definition.string.begin.c\n- token from 8 to 21 (Hello, World!) with scopes C, meta.block.c, meta.function-call.c, string.quoted.double.c\n- token from 21 to 22 (\") with scopes C, meta.block.c, meta.function-call.c, string.quoted.double.c, punctuation.definition.string.end.c\n- token from 22 to 23 ()) with scopes C, meta.block.c, meta.function-call.c, punctuation.section.arguments.end.bracket.round.c\n- token from 23 to 24 (;) with scopes C, meta.block.c, punctuation.terminator.statement.c\n- token from 0 to 6 (return) with scopes C, meta.block.c, keyword.control.c\n- token from 6 to 7 ( ) with scopes C, meta.block.c\n- token from 7 to 8 (0) with scopes C, meta.block.c, constant.numeric.decimal.c\n- token from 8 to 9 (;) with scopes C, meta.block.c, punctuation.terminator.statement.c\n```\n\n从这一步，我们可以拿到一个 Tokenizer 后的结果，如我们 include 的情况等等。\n\n#### 2. DSL 转换\n\n随后，我们要将上述的 Token 进行转换，转换到特定的 DSL，这里暂时称之为 Translator DSL。\n\nTranslator DSL 将映射到 Poet DSL 上。\n\n#### 3. 生成 Charj 代码\n\n即，代码中的：https://github.com/charj-lang/charj-poet\n\n#### 4. Charj 编辑与代码优化\n\n[https://github.com/charj-lang/charj](https://github.com/charj-lang/charj)\n\n#### 5. 再次转换\n\n理想情况下，通过我们的 Translator DSL，就可以再度将代码转换为新的语言。\n\n![流程图](https://github.com/charj-lang/arts/blob/master/charj-process.png?raw=true)\n\n## Related\n\n[https://github.com/usethesource/rascal](https://github.com/usethesource/rascal) is a meta-programming language. It contains the interpreter, the parser generator, the parser run-time, the standard library, the online documentation and the type checker.\n\n## FAQ\n\n### 如何支持内置函数？\n\n来源：内置函数你怎么搞，比如打开文件 Python 是 Open，C++ 是 Stream，API 都不一样？\n\nCharj 并不会支持内置函数的转换。 Charj 关心的是语言的互转，可以简单的认为 AST 的互转，不考虑编译等场景。\n\n对应未来可能的支持方案：对内置函数进行接口封装，等转换到新语言后，再由开发者实现这些接口。\n\n### 是否实现虚拟机？\n\n需要等到有精力的时间再考虑。\n\n### C++ 的支持程度？\n\nC++ 过于复杂，未来只会出现有限的 C++ 支持。\n\n### Go Context？\n\n是否要实现一些库去模拟 Context 的 Timeout Cancel？\n\n### EBNF\n\n### 其它 Suggestions\n\n#### Notes\n\nfrom [雾色](https://www.zhihu.com/people/yunlongyun)\n\n> 为什么要编程语言转编程语言呢？如果可以从伪代码快速转化成编程语言不是也可以吗？并且这种抽象层次是比较稳定的。我们缺少伪代码转换成任何编程语言的工具。就像智能提示，我们可以把伪代码分解成细粒度，每个伪代码的名词都可以在网络库中找到对象，动词有方法，形容词有属性，再通过逻辑组织起来，每个细粒度的对象和逻辑都能被转换成任何编程语言。\n\n> 我的意思是建立通用语言的标准，并尝试建立其中一门主流语言的对象库，甚至是脱离对象的通用方法和通用属性，在类似vscode这种编辑器中提供伪代码到对象或者函数的接口，每个人都能发布他的一个函数、一个对象、一个通用方法、一个通用属性到这个网络上的平台，其它人写伪代码时就可以直接提示出他选择的语言相关的对象、函数或者方法了。这样算不算实现了跨语言呢。把语言转换留给编程者去做，而这边只是提供一个平台、标准、接口或者编辑器插件。就像超强的tabnine。\n\n> 可以把你伪代码中的任意一个词，给出许多（开源实时添加的）智能提示，比如我要实现一个算法，让篮子里的苹果增加一个。\n通过nlp分词并解析出词性，再给出对应的提示，篮子、苹果的对象，增加这个方法，一个这个数词可能是调用方法的循环次数。到最后自己需要的是组织，并且实现网络提示接口中没有的对象和方法，并自动上传。粒度可以是自由的，可以实现一个复杂的功能，可以实现一个简单点方法。将这种方法按照业务领域或者主题来划分。\n\n\nfrom [灵剑](https://www.zhihu.com/people/ling-jian-94)\n\n> 简单听完有一些很深切的疑问：1. 不同语言的解析模型就不一样，正则表达式解析语法树这样的想法会不会太naive了一点？比如说C++的语法纯粹就是上下文相关的，a<b,c>d这样的结构有多义性，不可能单纯通过文法变成语法树；再比如说Python的语法跟缩进层级是有关的。2. 能变成语法树不代表就能做相互转码，首先不同语言的功能不一样，虽然说图灵完备的语言原则上都可以相互表达，但是这个相互转化的过程本身可能代价会超乎想象，甚至不得不以某种类似于虚拟机解释执行的方式运行；其次，标准库差异的问题难以解决，操作系统API之类的更难。更不要说跟第三方库二进制连接的问题了。\n\n\n\n"},"__N_SSG":true}